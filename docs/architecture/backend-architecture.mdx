# Backend Architecture Specification

## Overview

The Auterity backend is a modern Python-based API server built with FastAPI, designed for high performance, scalability, and maintainability. The architecture follows microservices principles with clear separation of concerns and domain-driven design patterns.

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                      Client Layer                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │   Web App   │  │ Mobile App  │  │ Third Party │            │
│  │   React     │  │   Native    │  │    APIs     │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
├─────────────────────────────────────────────────────────────────┤
│                       API Gateway                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │ Rate Limit  │  │    CORS     │  │    Auth     │            │
│  │ Middleware  │  │ Middleware  │  │ Middleware  │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
├─────────────────────────────────────────────────────────────────┤
│                    FastAPI Application                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │   Auth API  │  │Workflow API │  │Template API │            │
│  │             │  │             │  │             │            │
│  │ /auth/*     │  │/workflows/* │  │/templates/* │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │Execution API│  │Monitoring   │  │ WebSocket   │            │
│  │             │  │    API      │  │   Server    │            │
│  │/executions/*│  │ /metrics/*  │  │   /ws/*     │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
├─────────────────────────────────────────────────────────────────┤
│                     Service Layer                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │  Workflow   │  │  Template   │  │ AI Service  │            │
│  │   Engine    │  │   Engine    │  │             │            │
│  │             │  │             │  │ OpenAI GPT  │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │    Auth     │  │   Email     │  │   File      │            │
│  │  Service    │  │  Service    │  │  Service    │            │
│  │             │  │             │  │             │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
├─────────────────────────────────────────────────────────────────┤
│                      Data Layer                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │ PostgreSQL  │  │    Redis    │  │ File Store  │            │
│  │             │  │             │  │             │            │
│  │ Primary DB  │  │   Cache     │  │   S3/Blob   │            │
│  │ Workflows   │  │  Sessions   │  │   Storage   │            │
│  │ Users       │  │  Rate Limit │  │   Assets    │            │
│  │ Executions  │  │             │  │             │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

## Core Components

### 1. FastAPI Application

#### Application Factory Pattern

```python
# app/main.py
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from app.core.config import settings
from app.api import auth, workflows, templates, executions

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    await startup_event()
    yield
    # Shutdown
    await shutdown_event()

def create_application() -> FastAPI:
    app = FastAPI(
        title="Auterity API",
        description="AI-powered workflow automation platform",
        version="1.0.0",
        lifespan=lifespan,
    )

    # Middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.CORS_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Routers
    app.include_router(auth.router, prefix="/api/auth", tags=["authentication"])
    app.include_router(workflows.router, prefix="/api/workflows", tags=["workflows"])
    app.include_router(templates.router, prefix="/api/templates", tags=["templates"])
    app.include_router(executions.router, prefix="/api/executions", tags=["executions"])

    return app

app = create_application()
```

### 2. Database Layer

#### SQLAlchemy Models

```python
# app/models/workflow.py
from sqlalchemy import Column, String, Text, ForeignKey, Enum, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
import enum

from .base import BaseModel

class WorkflowStatus(enum.Enum):
    DRAFT = "draft"
    ACTIVE = "active"
    INACTIVE = "inactive"
    ARCHIVED = "archived"

class Workflow(BaseModel):
    __tablename__ = "workflows"

    name = Column(String(255), nullable=False)
    description = Column(Text)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    status = Column(Enum(WorkflowStatus), default=WorkflowStatus.DRAFT)
    definition = Column(JSON, nullable=False)

    # Relationships
    user = relationship("User", back_populates="workflows")
    executions = relationship("WorkflowExecution", back_populates="workflow")
```

### 3. Service Layer

#### Workflow Engine Service

```python
# app/services/workflow_engine.py
from typing import Dict, Any, List, Optional
from sqlalchemy.ext.asyncio import AsyncSession
import asyncio
import logging

from app.models.workflow import Workflow, WorkflowExecution, ExecutionStatus
from app.services.ai_service import AIService

logger = logging.getLogger(__name__)

class WorkflowEngine:
    def __init__(self, db: AsyncSession, ai_service: AIService):
        self.db = db
        self.ai_service = ai_service

    async def execute_workflow(
        self,
        workflow_id: str,
        input_data: Dict[str, Any]
    ) -> str:
        """Execute a workflow and return execution ID."""

        # Get workflow
        workflow = await self._get_workflow(workflow_id)
        if not workflow:
            raise WorkflowExecutionError(f"Workflow {workflow_id} not found")

        # Create execution record
        execution = WorkflowExecution(
            workflow_id=workflow_id,
            input_data=input_data,
            status=ExecutionStatus.PENDING
        )
        self.db.add(execution)
        await self.db.commit()
        await self.db.refresh(execution)

        # Execute workflow asynchronously
        asyncio.create_task(self._execute_workflow_steps(execution))

        return str(execution.id)
```

## Performance Optimization

### Database Optimization

```python
# Database connection pooling and optimization
from sqlalchemy import event
from sqlalchemy.engine import Engine
import time

@event.listens_for(Engine, "before_cursor_execute")
def receive_before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    context._query_start_time = time.time()

@event.listens_for(Engine, "after_cursor_execute")
def receive_after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    total = time.time() - context._query_start_time
    if total > 0.1:  # Log slow queries
        logger.warning(f"Slow query: {total:.2f}s - {statement[:100]}")
```

### Caching Strategy

```python
# app/utils/cache.py
import redis
import json
from typing import Any, Optional
from functools import wraps

redis_client = redis.from_url(settings.REDIS_URL)

def cache_result(expiration: int = 300):
    """Decorator to cache function results."""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Generate cache key
            cache_key = f"{func.__name__}:{hash(str(args) + str(kwargs))}"

            # Try to get from cache
            cached_result = redis_client.get(cache_key)
            if cached_result:
                return json.loads(cached_result)

            # Execute function and cache result
            result = await func(*args, **kwargs)
            redis_client.setex(
                cache_key,
                expiration,
                json.dumps(result, default=str)
            )

            return result
        return wrapper
    return decorator
```

## Next Steps

- [Frontend Architecture](/architecture/frontend-architecture) - Frontend implementation
- [System Architecture](/architecture/system-architecture) - Overall system design
- [Production Deployment](/deployment/production-deployment) - Deploy to production

---

**Document Version**: 1.0
**Last Updated**: $(date)
**Architecture Review**: Monthly backend architecture assessment
**Maintained By**: Auterity Backend Team
