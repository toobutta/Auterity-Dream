# Frontend Architecture Specification

## Overview

The Auterity frontend is a modern React-based single-page application (SPA) built with TypeScript, designed for scalability, maintainability, and optimal user experience. The architecture follows component-based design principles with clear separation of concerns.

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        Browser Layer                            │
├─────────────────────────────────────────────────────────────────┤
│                     React Application                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │   Pages     │  │ Components  │  │   Hooks     │            │
│  │             │  │             │  │             │            │
│  │ Dashboard   │  │ WorkflowBuilder │ useAuth    │            │
│  │ Workflows   │  │ TemplateCard│  │ useAPI     │            │
│  │ Templates   │  │ ErrorBoundary│  │ useWebSocket│           │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │  Contexts   │  │   Utils     │  │   Types     │            │
│  │             │  │             │  │             │            │
│  │ AuthContext │  │ apiClient   │  │ Workflow    │            │
│  │ ErrorContext│  │ validation  │  │ Template    │            │
│  │ ThemeContext│  │ formatting  │  │ User        │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
├─────────────────────────────────────────────────────────────────┤
│                      API Layer                                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │ REST Client │  │ WebSocket   │  │ Auth Client │            │
│  │             │  │             │  │             │            │
│  │ Axios       │  │ Socket.IO   │  │ JWT Handler │            │
│  │ Interceptors│  │ Real-time   │  │ Token Mgmt  │            │
│  │ Error Handling│ │ Updates    │  │ Refresh     │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

## Component Architecture

### Component Hierarchy

```
App
├── AuthProvider
│   ├── ErrorProvider
│   │   ├── Router
│   │   │   ├── ProtectedRoute
│   │   │   │   ├── Layout
│   │   │   │   │   ├── Header
│   │   │   │   │   ├── Sidebar
│   │   │   │   │   └── Main
│   │   │   │   │       ├── Dashboard
│   │   │   │   │       ├── Workflows
│   │   │   │   │       ├── Templates
│   │   │   │   │       └── WorkflowBuilder
│   │   │   │   └── ErrorBoundary
│   │   │   └── PublicRoute
│   │   │       ├── LoginForm
│   │   │       └── RegisterForm
│   │   └── ErrorToast
│   └── LoadingSpinner
```

### Component Design Principles

#### 1. Single Responsibility
Each component has a single, well-defined purpose:
- **Presentational Components**: Focus on UI rendering
- **Container Components**: Handle data fetching and state management
- **Hook Components**: Encapsulate reusable logic

#### 2. Composition over Inheritance
Components are composed together rather than using inheritance:
```typescript
// Good: Composition
const WorkflowCard = ({ workflow, onEdit, onDelete }) => (
  <Card>
    <CardHeader title={workflow.name} />
    <CardBody content={workflow.description} />
    <CardActions onEdit={onEdit} onDelete={onDelete} />
  </Card>
);
```

#### 3. Props Interface Design
Clear, typed interfaces for all component props:
```typescript
interface WorkflowBuilderProps {
  workflow?: Workflow;
  onSave: (workflow: Workflow) => Promise<void>;
  onCancel: () => void;
  readonly?: boolean;
}
```

## State Management

### Global State Architecture

```
Application State
├── Authentication State (AuthContext)
│   ├── user: User | null
│   ├── token: string | null
│   ├── isAuthenticated: boolean
│   └── permissions: Permission[]
├── Error State (ErrorContext)
│   ├── errors: Error[]
│   ├── showError: (error: Error) => void
│   └── clearErrors: () => void
├── Theme State (ThemeContext)
│   ├── theme: 'light' | 'dark'
│   ├── toggleTheme: () => void
│   └── colors: ColorPalette
└── Local Component State
    ├── Form State (React Hook Form)
    ├── UI State (useState)
    └── Server State (React Query)
```

### State Management Patterns

#### 1. Context for Global State
```typescript
// AuthContext.tsx
interface AuthContextType {
  user: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
}

export const AuthContext = createContext<AuthContextType | null>(null);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

#### 2. React Query for Server State
```typescript
// hooks/useWorkflows.ts
export const useWorkflows = () => {
  return useQuery({
    queryKey: ['workflows'],
    queryFn: () => workflowAPI.getWorkflows(),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
  });
};

export const useCreateWorkflow = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: workflowAPI.createWorkflow,
    onSuccess: () => {
      queryClient.invalidateQueries(['workflows']);
    },
  });
};
```

## API Integration

### HTTP Client Configuration

```typescript
// api/client.ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';

class APIClient {
  private client: AxiosInstance;

  constructor(baseURL: string) {
    this.client = axios.create({
      baseURL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // Request interceptor for auth token
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('auth_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor for error handling
    this.client.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          // Handle unauthorized access
          this.handleUnauthorized();
        }
        return Promise.reject(error);
      }
    );
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.get(url, config);
    return response.data;
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.post(url, data, config);
    return response.data;
  }
}
```

## Performance Optimization

### Code Splitting

```typescript
// Lazy loading for route-based splitting
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Workflows = lazy(() => import('./pages/Workflows'));
const Templates = lazy(() => import('./pages/Templates'));
const WorkflowBuilder = lazy(() => import('./pages/WorkflowBuilder'));
```

### Memoization

```typescript
// React.memo for component memoization
export const WorkflowCard = React.memo<WorkflowCardProps>(({ workflow, onEdit }) => {
  return (
    <div className="workflow-card">
      <h3>{workflow.name}</h3>
      <p>{workflow.description}</p>
      <button onClick={() => onEdit(workflow.id)}>Edit</button>
    </div>
  );
});

// useMemo for expensive calculations
const WorkflowList = ({ workflows, searchTerm }) => {
  const filteredWorkflows = useMemo(() => {
    return workflows.filter(workflow =>
      workflow.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [workflows, searchTerm]);

  return (
    <div>
      {filteredWorkflows.map(workflow => (
        <WorkflowCard key={workflow.id} workflow={workflow} />
      ))}
    </div>
  );
};
```

## Error Handling

### Error Boundary Implementation

```typescript
// components/ErrorBoundary.tsx
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

export class ErrorBoundary extends Component<
  PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error, errorInfo: null };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({ errorInfo });

    // Log error to monitoring service
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <details>
            <summary>Error details</summary>
            <pre>{this.state.error?.toString()}</pre>
            <pre>{this.state.errorInfo?.componentStack}</pre>
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Next Steps

- [Backend Architecture](/architecture/backend-architecture) - Backend implementation
- [System Architecture](/architecture/system-architecture) - Overall system design
- [Production Deployment](/deployment/production-deployment) - Deploy to production

---

**Document Version**: 1.0
**Last Updated**: $(date)
**Architecture Review**: Monthly architecture assessment
**Maintained By**: Auterity Frontend Team
